Ngày 1: Làm quen với CustomPainter và Canvas
* Giờ 1-2: Tìm hiểu cơ bản về CustomPaint widget và CustomPainter class. Học cách khởi tạo một custom painter và sử dụng trong một ứng dụng Flutter.
* Giờ 3: Luyện tập vẽ các đường thẳng và đường tròn sử dụng các phương thức của đối tượng Canvas.
* Giờ 4: Thực hiện một bài tập vẽ một hình đơn giản kết hợp đường thẳng và đường tròn để tạo hình ngôi sao hoặc mặt cười.
Ngày 2: Khám phá nhiều hình dạng và kiểu vẽ khác nhau
* Giờ 1-2: Học về các kiểu vẽ khác nhau (Paint), bao gồm màu sắc, độ dày, đường nét, và hiệu ứng.
* Giờ 3: Vẽ các hình học cơ bản như hình vuông, hình chữ nhật, tam giác.
* Giờ 4: Kết hợp các hình đã học để tạo một bức tranh đơn giản, ví dụ như một ngôi nhà hoặc cây cối.
Ngày 3: Làm việc với đường cong và Path
* Giờ 1-2: Tìm hiểu về Path và cách tạo các đường cong Bezier.
* Giờ 3-4: Thực hành vẽ một bông hoa hoặc một đám mây sử dụng các đường cong, sử dụng Path.
Ngày 4: Biến đổi và hiệu ứng
* Giờ 1-2: Học các biến đổi cơ bản trong Canvas, bao gồm di chuyển, xoay, và tỷ lệ.
* Giờ 3-4: Áp dụng các biến đổi để tạo hiệu ứng động cho hình vẽ, ví dụ như làm cho một hình tròn xoay quanh.
Ngày 5: Áp dụng Gradient và Màu sắc
* Giờ 1-2: Tìm hiểu và thực hành với Gradient để tạo ra các hiệu ứng màu sắc cho hình vẽ.
* Giờ 3-4: Vẽ một bức tranh phong cảnh đơn giản sử dụng gradient cho bầu trời và nước.
Ngày 6: Làm việc với Text và Hình ảnh
* Giờ 1-2: Học cách thêm văn bản vào trong Canvas.
* Giờ 3-4: Học cách sử dụng hình ảnh như một phần của bức tranh, ví dụ như thêm hình ảnh nền.
Ngày 7: Dự án cuối khóa
* Giờ 1-4: Sử dụng tất cả các kỹ năng đã học để tạo một ứng dụng mini hoặc một trò chơi đơn giản. Ví dụ, một trò chơi đơn giản nơi người dùng phải né tránh các hình dạng di chuyển trên màn hình, hoặc một ứng dụng vẽ đơn giản cho phép người dùng tạo ra các bức tranh của riêng họ.

Ngày 1: Đơn Giản với Đường Thẳng và Đường Tròn
* Bài Thực Hành: Vẽ một bức tranh đơn giản gồm mặt trời và mặt trăng. Sử dụng đường tròn để vẽ mặt trời và mặt trăng, và đường thẳng để vẽ các tia nắng.
Ngày 2: Hình Dạng Cơ Bản
* Bài Thực Hành: Tạo một bức tranh kết hợp hình vuông, hình chữ nhật, và tam giác để vẽ một ngôi nhà đơn giản với mái nhà, cửa sổ và cửa ra vào.
Ngày 3: Sử Dụng Đường Cong và Path
* Bài Thực Hành: Vẽ một cây với nhiều cành lá sử dụng Path và đường cong. Mỗi cành của cây sử dụng một đường cong Bezier để tạo hình.
Ngày 4: Biến Đổi và Hiệu Ứng
* Bài Thực Hành: Vẽ một chiếc đồng hồ cát, sử dụng biến đổi để xoay chiếc đồng hồ. Hình vẽ sẽ có hai phần trụ tròn cho cát rơi và phần giữa hẹp lại.
Ngày 5: Gradient và Màu Sắc
* Bài Thực Hành: Tạo một bức tranh hoàng hôn trên biển. Sử dụng gradient cho bầu trời và biển. Thêm mặt trời đang lặn vào đường chân trời.
Ngày 6: Làm Việc với Text và Hình Ảnh
* Bài Thực Hành: Vẽ một poster quảng cáo cho một sự kiện, kết hợp text và hình ảnh. Poster bao gồm thông tin về sự kiện với hình ảnh hấp dẫn và các chi tiết về thời gian, địa điểm.
Ngày 7: Dự Án Cuối Khóa
* Bài Thực Hành: Phát triển một trò chơi đơn giản nơi người dùng điều khiển một hình dạng (ví dụ, một quả bóng) tránh các chướng ngại vật di chuyển trên màn hình. Trò chơi cần tính điểm dựa trên thời gian sống sót và hiển thị điểm số trong thời gian thực.

tạo hoa văn
Hoạ tiết so le
hiểu về ma trận
tạo một hieu ung ngau nhien
tạo hiêu ưng nhiễu giống tv
Tạo shader mô phỏng một dòng chảy
Nhiễu mô phỏng tế bào 
Nhiễu dòng chảy nhiều màu


// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

float random (in vec2 _st) {
    return fract(sin(dot(_st.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) {
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

#define NUM_OCTAVES 5

float fbm ( in vec2 _st) {
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(cos(0.5), sin(0.5),
                    -sin(0.5), cos(0.50));
    for (int i = 0; i < NUM_OCTAVES; ++i) {
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    }
    return v;
}

void main() {
    vec2 st = gl_FragCoord.xy/u_resolution.xy*3.;
    // st += st * abs(sin(u_time*0.1)*3.0);
    vec3 color = vec3(0.0);

    vec2 q = vec2(0.);
    q.x = fbm( st + 0.00*u_time);
    q.y = fbm( st + vec2(1.0));

    vec2 r = vec2(0.);
    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*u_time );
    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*u_time);

    float f = fbm(st+r);

    color = mix(vec3(0.101961,0.619608,0.666667),
                vec3(0.666667,0.666667,0.498039),
                clamp((f*f)*4.0,0.0,1.0));

    color = mix(color,
                vec3(0,0,0.164706),
                clamp(length(q),0.0,1.0));

    color = mix(color,
                vec3(0.666667,1,1),
                clamp(length(r.x),0.0,1.0));

    gl_FragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);
}
